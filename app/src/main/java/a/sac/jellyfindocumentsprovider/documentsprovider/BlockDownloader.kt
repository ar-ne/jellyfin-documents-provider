package a.sac.jellyfindocumentsprovider.documentsprovider

import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.asCoroutineDispatcher
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.RandomAccessFile
import java.net.HttpURLConnection
import java.net.URL
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.Executors
import kotlin.concurrent.thread
import kotlin.math.ceil

/**
 * class generated by GPT-4
 * prompt:
 * write a kotlin class which download URL into buffer file by X-MB blocks
 * using multi-threaded(n-threads) queue for download, and have the following
 * function: can randomly readonly access the buffer file while downloading,
 * and if the accessed location not available(in a not downloaded block), it
 * will queue this block immediately(don't cancel current running download, if
 * it's the same block, just wait for it to finish). this class should also
 * have the ability to report which blocks has been fetched from internet.
 */
class BlockDownloader(
    private val url: URL,
    blockSizeMB: Int,
    private val numThreads: Int
) {
    private val blockBufferSize = blockSizeMB * 1024 * 1024
    private val tempFile: File = createTempFile()
    private val downloadedBlocks = ConcurrentHashMap<Int, Boolean>()
    private val jobsInProgress = mutableSetOf<Int>()
    var contentLength: Long = 0

    private val dispatcher by lazy {
        Executors.newFixedThreadPool(numThreads).asCoroutineDispatcher()
    }

    init {
        val connection = createConnection()
        contentLength = connection.contentLengthLong
        connection.disconnect()
        thread(start = true) {
            runBlocking {
                download()
            }
        }
    }

    private suspend fun download() = coroutineScope {
        val numBlocks = ceil(contentLength.toDouble() / blockBufferSize).toInt()
        val tasks = mutableListOf<Deferred<Unit>>()

        (0 until numBlocks).forEach { blockIdx ->
            tasks.add(async(dispatcher) { downloadBlock(blockIdx) })
        }

        tasks.awaitAll()
    }

    // Returns true if the block has been fetched, otherwise false.
    private fun isBlockDownloaded(blockIdx: Int): Boolean {
        return downloadedBlocks[blockIdx] ?: false
    }

    suspend fun read(offset: Long, length: Int): ByteArray {
        require(offset >= 0 && length > 0) { "Invalid offset or length" }

        val startBlock = (offset / blockBufferSize).toInt()
        val endBlock = ((offset + length - 1) / blockBufferSize).toInt()

        coroutineScope {
            (startBlock..endBlock)
                .filterNot { isBlockDownloaded(it) }
                .forEach { blockIdx ->
                    launch(dispatcher) { downloadBlock(blockIdx) }
                }
        }

        return withContext(Dispatchers.IO) {
            RandomAccessFile(tempFile, "r").use { file ->
                file.seek(offset)
                ByteArray(length).apply { file.read(this) }
            }
        }
    }

    private fun downloadBlock(blockIdx: Int) {
        if (!jobsInProgress.add(blockIdx)) return // Ignore if the job is already in progress.

        val connection = createConnection().apply {
            setRequestProperty(
                "Range",
                "bytes=${blockIdx * blockBufferSize}-${(blockIdx + 1) * blockBufferSize - 1}"
            )
        }

        connection.inputStream.use { input ->
            RandomAccessFile(tempFile, "rw").use {
                it.seek(blockIdx * blockBufferSize.toLong())
                FileOutputStream(it.fd).use { output ->
                    input.copyTo(output)
                }
            }
        }

        downloadedBlocks[blockIdx] = true
        jobsInProgress.remove(blockIdx)
    }

    private fun createConnection(): HttpURLConnection =
        (url.openConnection() as HttpURLConnection).apply {
            connectTimeout = 5000
            readTimeout = 5000
            requestMethod = "GET"
        }

}